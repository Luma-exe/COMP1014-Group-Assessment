install.packages("locks5Data")
install.packages("locks5Data")
Lock5Data::ExerciseHours
ExerciseHours
str(df)
df <- Lock5Data::ExerciseHours
str(df)
library(tidyverse)
df <- tibble(df)
library(tidyverse)
install.packages("tidyverse")
library(tidyverse)
df <- tibble(df)
df["Exercise"]
counts_of_sex_hand <- table(df$Sex, df$Hand)
install.packages("locks5Data")
install.packages("locks5Data")
install.packages("tidyverse")
install.packages("locks5Data")
install.packages("tidyverse")
install.packages("locks5Data")
install.packages("tidyverse")
install.packages("Lock5Data")
install.packages("Lock5Data")
install.packages("tinytex")
install.packages("locks5Data")
install.packages("locks5Data")
install.packages("locks5Data")
install.packages("Rtools")
install.packages("locks5Data")
#1)
install.packages("Rtools")
install.packages("locks5Data")
noDichM <- 0.50450
pMale <- 0.50450
noDichF <- 0.00015
pFemale <- 0.48295
pNoDich <- (noDichM * pMale) + (noDichF * pFemale)
pMaleNoDich <- (noDichM * pMale) / pNoDich
print(pMaleNoDich)
counts_of_sex_hand <- table(df$Sex, df$Hand)
data(ACS)
str(ACS)
data(ACS)
str(ACS)
##a)
```{r}
data(ACS)
```{r echo=FALSE}
install.packages("locks5Data")
#1) The dataset ACS contains the results of 2000 individual residents from the US, each of these representing a case. On the other hand the bootstrap distribution is of multiple resampled datasets, each containing a subset of the original cases. The dataset ACS includes a variable called "Language" which represents the language spoken at home. The bootstrap distribution is based on the distribution of proportions of people speaking English at home, which is derived from resampling the "Language" variable.
#2)
##a)
```{r}
language <- ACS$Language
data(ACS)
language <- ACS$Language
library(Lock5Data)
data(ACS)
str(ACS)
language <- ACS$Language
num_bootstraps <- 1000
bootstrap_proportions <- numeric(num_bootstraps)
for (i in 1:num_bootstraps) {
bootstrap_sample <- sample(language, replace = TRUE)
bootstrap_proportion <- mean(bootstrap_sample == 1)
bootstrap_proportions[i] <- bootstrap_proportion
}
head(bootstrap_proportions)
lowerQ <- quantile(botsrProportionO, 0.005)
library(Lock5Data)
data(ACS)
str(ACS)
lowerQ <- quantile(botsrProportionO, 0.005)
library(Lock5Data)
data(ACS)
str(ACS)
language <- ACS$Language
botsrNum <- 1000
botsrProportionO <- numeric(botsrNum)
for (i in 1:botsrNum) {
botsrSample <- sample(language, replace = TRUE)
botsrProportion <- mean(botsrSample == 1)
botsrProportionO[i] <- botsrProportion
}
lowerQ <- quantile(botsrProportionO, 0.005)
upperQ <- quantile(botsrProportionO, 0.995)
cat("99% Confidence Interval for Proportion of People Speaking English at Home:", lowerQ, "-", upperQ, "\n")
library(Lock5Data)
data(ACS)
language <- ACS$Language
botsrNum <- 1000
botsrProportionO <- numeric(botsrNum)
for (i in 1:botsrNum) {
botsrSample <- sample(language, replace = TRUE)
botsrProportion <- mean(botsrSample == 1)
botsrProportionO[i] <- botsrProportion
}
lowerQ <- quantile(botsrProportionO, 0.005)
upperQ <- quantile(botsrProportionO, 0.995)
cat("99% Confidence Interval for Proportion of People Speaking English at Home:", lowerQ, "-", upperQ, "\n")
a
library(Lock5Data)
data(ACS)
language <- ACS$Language
botsrNum <- 1000
botsrProportionO <- numeric(botsrNum)
for (i in 1:botsrNum) {
botsrSample <- sample(language, replace = TRUE)
botsrProportion <- mean(botsrSample == 1)
botsrProportionO[i] <- botsrProportion
}
lowerQ <- quantile(botsrProportionO, 0.005)
upperQ <- quantile(botsrProportionO, 0.995)
cat("99% Confidence Interval for Proportion of People Speaking English at Home:", lowerQ, "-", upperQ, "\n")
library(Lock5Data)
str(ACS)
language <- ACS$Language
botsrNum <- 1000
botsrProportionO <- numeric(botsrNum)
for (i in 1:botsrNum) {
botsrSample <- sample(language, replace = TRUE)
botsrProportion <- mean(botsrSample == 1)
botsrProportionO[i] <- botsrProportion
}
lowerQ <- quantile(botsrProportionO, 0.005)
upperQ <- quantile(botsrProportionO, 0.995)
cat("99% Confidence Interval for Proportion of People Speaking English at Home:", lowerQ, "-", upperQ, "\n")
library(Lock5Data)
data(ACS)
str(ACS)
language <- ACS$Language
botsrNum <- 1000
botsrProportionO <- numeric(botsrNum)
lowerQ <- quantile(botsrProportionO, 0.005)
upperQ <- quantile(botsrProportionO, 0.995)
cat("99% Confidence Interval for Proportion of People Speaking English at Home:", lowerQ, "-", upperQ, "\n")
library(Lock5Data)
data(ACS)
str(ACS)
language <- ACS$Language
botsrNum <- 1000
botsrProportionO <- numeric(botsrNum)
for (i in 1:botsrNum) {
botsrSample <- sample(language, replace = TRUE)
botsrProportion <- mean(botsrSample == 1)
botsrProportionO[i] <- botsrProportion
}
cat("99% Confidence Interval for Proportion of People Speaking English at Home:", lowerQ, "-", upperQ, "\n")
library(Lock5Data)
data(ACS)
str(ACS)
language <- ACS$Language
botsrNum <- 1000
botsrProportionO <- numeric(botsrNum)
for (i in 1:botsrNum) {
botsrSample <- sample(language, replace = TRUE)
botsrProportion <- mean(botsrSample == 1)
botsrProportionO[i] <- botsrProportion
}
lowerQ <- quantile(botsrProportionO, 0.005)
upperQ <- quantile(botsrProportionO, 0.995)
cat("99% Confidence Interval for Proportion of People Speaking English at Home:", lowerQ, "-", upperQ, "\n")
library(Lock5Data)
data(ACS)
str(ACS)
#VV for part A VV
language <- ACS$Language
botsrNum <- 1000
botsrProportionO <- numeric(botsrNum)
for (i in 1:botsrNum) {
botsrSample <- sample(language, replace = TRUE)
botsrProportion <- mean(botsrSample == 1)
botsrProportionO[i] <- botsrProportion
}
head(botsrProportionO)
#VV for part B VV
lowerQ <- quantile(botsrProportion, 0.005)
upperQ <- quantile(botsrProportion, 0.995)
cat("99% Confidence Interval for Proportion of People Speaking English at Home:", lowerQ, "-", upperQ, "\n")
library(Lock5Data)
data(ACS)
age <- ACS$Age
# Define the observed sample mean
observed_mean <- mean(age)
# Set the number of iterations for randomization
num_iterations <- 1000
# Initialize an empty vector to store randomization means
randomization_means <- numeric(num_iterations)
# Perform randomization
for (i in 1:num_iterations) {
# Shuffle the age variable
shuffled_age <- sample(age)
# Calculate the mean of the shuffled age variable
randomization_means[i] <- mean(shuffled_age)
}
# Plot the randomization distribution
hist(randomization_means, breaks = 30, main = "Randomization Distribution of Sample Means",
xlab = "Sample Mean Age", ylab = "Frequency")
abline(v = observed_mean, col = "red", lwd = 2)
library(Lock5Data)
data(ACS)
age <- ACS$Age
# Define the observed sample mean
observed_mean <- mean(age)
# Set the number of iterations for randomization
num_iterations <- 1000
# Initialize an empty vector to store randomization means
randomization_means <- numeric(num_iterations)
# Perform randomization
for (i in 1:num_iterations) {
# Shuffle the age variable
shuffled_age <- sample(age)
# Calculate the mean of the shuffled age variable
randomization_means[i] <- mean(shuffled_age)
}
# Plot the randomization distribution
hist(randomization_means, breaks = 30, main = "Randomization Distribution of Sample Means",
xlab = "Sample Mean Age", ylab = "Frequency")
abline(v = observed_mean, col = "red", lwd = 2)
library(Lock5Data)
data(ACS)
age <- ACS$Age
observedMean <- mean(age)
numIterations <- 1000
randomizationMeans <- numeric(numIterations)
for (i in 1:numIterations) {
shuffledAge <- sample(age)
randomizationMeans[i] <- mean(shuffledAge)
}
hist(randomizationMeans, breaks = 30, main = "Randomization Distribution of Sample Means",
xlab = "Sample Mean Age", ylab = "Frequency")
abline(v = observedMean, col = "red", lwd = 2)
library(Lock5Data)
data(ACS)
#PART A
age <- ACS$Age
observedMean <- mean(age)
numIterations <- 1000
randomizationMeans <- numeric(numIterations)
for (i in 1:numIterations) {
shuffledAge <- sample(age)
randomizationMeans[i] <- mean(shuffledAge)
}
hist(randomizationMeans, breaks = 30, main = "Randomization Distribution of Sample Means",
xlab = "Sample Mean Age", ylab = "Frequency")
abline(v = observedMean, col = "red", lwd = 2)
#PART B
pValue <- sum(randomizationMeans >= observedMean) / numIterations
pValue
n <- 10
p <- 0.05
expected_value <- n * p
expected_value
twoPearls <- sum(dbinom(2:10, size = n, prob = p))
twoPearls
mean <- 100  # Mean
standardDeviation <- 10  # Standard deviation
numOfPearls <- 15  # Number of pearls found
total <- numOfPearls * mean  # Total value of pearls found
# VV (a)
expected <- total
expected
#VV (b)
standardDeviation_Y <- sqrt(numOfPearls) * standardDeviation
standardDeviation_Y
#VV (c)
x <- 1502
z <- (x - total) / standardDeviation_Y
pValue <- pnorm(z)
pValue
# VV (a)
sampleProportion <- 20/300
sampleSize <- 300
standardError <- sqrt(sampleProportion * (1 - sampleProportion) / sampleSize)
standardError
#VV (b)
sampleProportion <- 20/300
standardError <- 0.034
zValue <- qnorm(0.95)
lowerBound <- sampleProportion - zValue * standardError
upperBound <- sampleProportion + zValue * standardError
lowerBound
upperBound
#VV (c)
marginError <- 0.018
zValue <- qnorm(0.95)
required_n <- (zValue * standardError / marginError)^2
required_n
# VV (a)
#Null Hypothesis (H₀): The variables Language and Married are independent.
#Alternative Hypothesis (H₁): The variables Language and Married are not independent.
# VV (b)
contingency_table <- table(acs_data$Language, acs_data$Married)
library(Lock5Data)
# VV (a)
#Null Hypothesis (H₀): The variables Language and Married are independent.
#Alternative Hypothesis (H₁): The variables Language and Married are not independent.
# VV (b)
contingency_table <- table(acs_data$Language, acs_data$Married)
library(Lock5Data)
library(Lock5Data)
# VV (a)
#Null Hypothesis (H₀): The variables Language and Married are independent.
#Alternative Hypothesis (H₁): The variables Language and Married are not independent.
# VV (b)
contingency_table <- table(acs_data$Language, acs_data$Married)
library(Lock5Data)
str(acs_data)
library("Lock5Data")
data(ACS)
attach(ACS)
# VV (a)
#Null Hypothesis (H₀): The variables Language and Married are independent.
#Alternative Hypothesis (H₁): The variables Language and Married are not independent.
# VV (b)
contingency_table <- table(acs_data$Language, acs_data$Married)
library("Lock5Data")
data(ACS)
attach(ACS)
# VV (a)
# Null Hypothesis (H₀): The variables Language and Married are independent.
# Alternative Hypothesis (H₁): The variables Language and Married are not independent.
# VV (b)
contingency_table <- table(Language, Married)
chi_test <- chisq.test(contingency_table)
chi_test_statistic <- chi_test$statistic
chi_test_p_value <- chi_test$p.value
chi_test_statistic
chi_test_p_value
# VV (c)
set.seed(123)
n_permutations <- 10000
chi_squared_stats <- numeric(n_permutations)
for (i in 1:n_permutations) {
permuted_married <- sample(Married)
permuted_table <- table(Language, permuted_married)
chi_squared_stats[i] <- chisq.test(permuted_table)$statistic
}
# VV (d)
observed_stat <- chi_test$statistic
p_value <- mean(chi_squared_stats >= observed_stat)
# Conclusion at 10% significance level
significance_level <- 0.10
conclusion <- ifelse(p_value < significance_level, "Reject H0", "Do not reject H0")
# Output results
list(
observed_statistic = observed_stat,
p_value = p_value,
conclusion = conclusion
)
setwd("~/GitHub/COMP1014-Group-Assessment")
knitr::opts_chunk$set(echo = TRUE)
usesMelatonin <- SleepCogStudy[SleepCogStudy$MelatoninUse == 1, ]
SleepCogStudy <- read.csv("Resources/Sleep_Cognition_Study_f1PhaXA.csv")
usesMelatonin <- SleepCogStudy[SleepCogStudy$MelatoninUse == 1, ]
noMelatonin <- SleepCogStudy[SleepCogStudy$MelatoninUse == 0, ]
mean(usesMelatonin$AverageSleepDuration)
mean(noMelatonin$AverageSleepDuration)
boxplot(usesMelatonin$AverageSleepDuration, noMelatonin$AverageSleepDuration,
names = c("Melatonin Users", "Non-Users"),
ylab = "Average Sleep Duration (hours)",
main = "Sleep Duration by Melatonin Use",
col = c("blue", "red"))
usesMelatonin <- SleepCogStudy[SleepCogStudy$MelatoninUse == 1, ]
noMelatonin <- SleepCogStudy[SleepCogStudy$MelatoninUse == 0, ]
mean(usesMelatonin$AverageSleepDuration)
mean(noMelatonin$AverageSleepDuration)
t.test(usesMelatonin$AverageSleepDuration, noMelatonin$AverageSleepDuration)
usesMelatonin <- SleepCogStudy[SleepCogStudy$MelatoninUse == 1, ]
noMelatonin <- SleepCogStudy[SleepCogStudy$MelatoninUse == 0, ]
mean(usesMelatonin$AverageSleepDuration)
mean(noMelatonin$AverageSleepDuration)
boxplot(usesMelatonin$AverageSleepDuration, noMelatonin$AverageSleepDuration,
names = c("Melatonin Users", "Non-Users"),
ylab = "Average Sleep Duration (hours)",
main = "Sleep Duration by Melatonin Use",
col = c("blue", "red"))
usesMelatonin <- SleepCogStudy[SleepCogStudy$MelatoninUse == 1, ]
noMelatonin <- SleepCogStudy[SleepCogStudy$MelatoninUse == 0, ]
mean(usesMelatonin$AverageSleepDuration)
mean(noMelatonin$AverageSleepDuration)
boxplot(usesMelatonin$AverageSleepDuration, noMelatonin$AverageSleepDuration,
names = c("Melatonin Users", "Non Melatonin Users"),
ylab = "Average Sleep Duration (hours)",
main = "Sleep Duration based off Melatonin Use",
col = c("blue", "red"))
mean(usesMelatonin$AverageSleepDuration)
mean(noMelatonin$AverageSleepDuration)
t.test(usesMelatonin$AverageSleepDuration, noMelatonin$AverageSleepDuration)
knitr::opts_chunk$set(echo = TRUE)
SleepCogStudy <- read.csv("Resources/Sleep_Cognition_Study_f1PhaXA.csv")
sleepDurGender <- SleepCogStudy[SleepCogStudy$Gender, ]
boxplot(AverageSleepDuration ~ Gender, data = sleepDurGender,
col = c("blue", "red"),
ylab = "Average Sleep Duration (hours)",
main = "Sleep Duration by Gender")
SleepCogStudy <- read.csv("Resources/Sleep_Cognition_Study_f1PhaXA.csv")
sleepDurGender <- na.omit(SleepCogStudy[, c("Gender", "AverageSleepDuration")])
boxplot(AverageSleepDuration ~ Gender, data = sleepDurGender,
col = c("blue", "red"),
ylab = "Average Sleep Duration (hours)",
main = "Sleep Duration by Gender")
t.test(AverageSleepDuration ~ Gender, data = sleepDurGender)
sleepDurGender <- na.omit(SleepCogStudy[, c("Gender", "AverageSleepDuration")])
boxplot(AverageSleepDuration ~ Gender, data = sleepDurGender,
col = rainbow(length(unique(sleepDurGender$Gender))),
ylab = "Average Sleep Duration (hours)",
main = "Sleep Duration by Gender")
anova_result <- aov(AverageSleepDuration ~ Gender, data = sleepDurGender)
summary(anova_result)
anova_result <- aov(AverageSleepDuration ~ Gender, data = sleepDurGender)
summary(anova_result)
